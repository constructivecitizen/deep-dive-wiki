-- Delete the current separate rows
DELETE FROM content_items;

-- Create one unified row that contains both folder info and document content
INSERT INTO content_items (
  id,
  type,
  title,
  path,
  parent_id,
  order_index,
  content_json,
  tags,
  created_at,
  updated_at
) VALUES (
  'f30f9e4f-1891-4950-9ce0-21b881a83317',
  'folder',
  'Deep Structures',
  '/deep-structures',
  NULL,
  0,
  '{"sections": [{"id": "overview", "tags": ["overview", "architecture"], "level": 1, "title": "System Overview", "content": "This comprehensive guide covers the complete system architecture from high-level concepts to detailed implementation specifics. It demonstrates the full capability of hierarchical documentation with 6 levels of depth."}, {"id": "frontend-architecture", "tags": ["frontend", "ui"], "level": 2, "title": "Frontend Architecture", "content": "The frontend layer handles user interactions and presentation logic, built with modern web technologies for optimal performance and user experience."}, {"id": "component-structure", "tags": ["components", "atomic-design"], "level": 3, "title": "Component Structure", "content": "Our component architecture follows atomic design principles, ensuring reusability and maintainability across the entire application."}, {"id": "ui-components", "tags": ["ui", "components", "accessibility"], "level": 4, "title": "UI Components", "content": "Base UI components provide the foundation for all user interface elements, implemented with accessibility and consistency in mind."}, {"id": "button-system", "tags": ["buttons", "variants"], "level": 5, "title": "Button System", "content": "The button system includes variants for different contexts: primary, secondary, ghost, outline, and destructive actions."}, {"id": "button-states", "tags": ["states", "interactions", "a11y"], "level": 6, "title": "Button States & Interactions", "content": "Each button supports multiple states: default, hover, active, focus, disabled, and loading. Interaction patterns follow accessibility guidelines with proper focus management and keyboard navigation."}, {"id": "form-components", "tags": ["forms", "validation"], "level": 5, "title": "Form Components", "content": "Form components handle user input with validation, error states, and accessibility features built-in."}, {"id": "input-validation", "tags": ["validation", "patterns", "ux"], "level": 6, "title": "Input Validation Patterns", "content": "Real-time validation provides immediate feedback while maintaining good UX. Validation rules are configurable and support both client-side and server-side validation."}, {"id": "layout-components", "tags": ["layout", "responsive", "grid"], "level": 4, "title": "Layout Components", "content": "Layout components provide consistent spacing, grid systems, and responsive behavior across all screen sizes."}, {"id": "responsive-grid", "tags": ["grid", "breakpoints", "responsive"], "level": 5, "title": "Responsive Grid System", "content": "The grid system adapts to different screen sizes with breakpoints at 640px, 768px, 1024px, and 1280px."}, {"id": "mobile-optimizations", "tags": ["mobile", "touch", "progressive-enhancement"], "level": 6, "title": "Mobile-First Optimizations", "content": "All components are designed mobile-first with progressive enhancement for larger screens. Touch targets meet accessibility guidelines with minimum 44px hit areas."}, {"id": "data-layer", "tags": ["data", "state", "api"], "level": 2, "title": "Data Layer Architecture", "content": "The data layer manages application state, API communications, and data persistence with efficient caching strategies."}, {"id": "state-management", "tags": ["state", "react", "hooks"], "level": 3, "title": "State Management", "content": "Application state is managed through a combination of React hooks, context providers, and external state libraries for complex scenarios."}, {"id": "global-state", "tags": ["global-state", "context", "reducers"], "level": 4, "title": "Global State Patterns", "content": "Global state is minimized and carefully managed through context providers and state reducers for predictable updates."}, {"id": "user-session", "tags": ["session", "security", "tokens"], "level": 5, "title": "User Session Management", "content": "User sessions are managed with secure token handling, automatic refresh, and proper cleanup on logout."}, {"id": "token-refresh", "tags": ["tokens", "refresh", "security", "background-service"], "level": 6, "title": "Automatic Token Refresh Strategy", "content": "Tokens are automatically refreshed before expiration using a background service. Failed refreshes trigger secure logout flows to protect user data."}, {"id": "api-integration", "tags": ["api", "rest", "services"], "level": 3, "title": "API Integration Layer", "content": "RESTful APIs are integrated through a standardized service layer with error handling, retry logic, and request/response transformation."}, {"id": "http-client", "tags": ["http", "client", "interceptors"], "level": 4, "title": "HTTP Client Configuration", "content": "The HTTP client includes automatic retry policies, request/response interceptors, and standardized error handling across all API calls."}, {"id": "retry-policies", "tags": ["retry", "circuit-breaker", "resilience"], "level": 5, "title": "Retry & Circuit Breaker Patterns", "content": "Exponential backoff retry policies handle temporary failures, while circuit breakers prevent cascading failures during service outages."}, {"id": "failure-scenarios", "tags": ["failure-handling", "offline", "degradation", "cache"], "level": 6, "title": "Graceful Failure Handling", "content": "When services are unavailable, the application degrades gracefully with cached data, offline modes, and clear user communication about service status."}, {"id": "backend-services", "tags": ["backend", "services", "business-logic"], "level": 2, "title": "Backend Services", "content": "Backend services provide business logic, data processing, and integration with external systems through well-defined APIs."}, {"id": "microservices", "tags": ["microservices", "scalability", "boundaries"], "level": 3, "title": "Microservices Architecture", "content": "Services are designed as independent, deployable units with clear boundaries and well-defined interfaces for maximum scalability and maintainability."}, {"id": "service-communication", "tags": ["communication", "events", "apis", "timeouts"], "level": 4, "title": "Inter-Service Communication", "content": "Services communicate through event-driven patterns and synchronous APIs, with proper error handling and timeout management."}, {"id": "event-patterns", "tags": ["events", "async", "consistency"], "level": 5, "title": "Event-Driven Patterns", "content": "Asynchronous events enable loose coupling between services while maintaining data consistency through eventual consistency patterns."}, {"id": "event-sourcing", "tags": ["event-sourcing", "audit", "immutable", "replay", "bi"], "level": 6, "title": "Event Sourcing Implementation", "content": "Critical business events are stored as an immutable log, enabling complete audit trails, replay capabilities, and temporal queries for business intelligence."}]}',
  ARRAY[]::text[],
  '2025-09-19 11:34:35.015255+00',
  '2025-09-19 11:34:35.015255+00'
);